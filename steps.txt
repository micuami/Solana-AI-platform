- directorul backend e facut manual
- Pipfile este creat folosind comanda "pipenv shell". e cam acelasi lucru cu
requirements.txt in sensul ca gestioneaza dependentele din Python. nu e nevoie
neaparat de amandoua. diferenta e ca Pipfile iti separa dependentele de productie 
(packages) de alea de dezvoltare (dev-packages). 
- Pipfile.lock iti fixeaza versiunile. E creat folosind pipenv install. Daca doua 
persoane din echipa ruleaza pipenv install fiecare o sa aiba acelasi mediu identic, 
nu doar compatibil. requirements.txt iti asigura compatibilitate. la deploy cu 
Pipfile.lock ai siguranta ca ruleaza cu aceleasi versiuni ca pe local. e la fel ca 
ce face package-lock.json. 
- pentru lucrul cu baze de date am folosit SQLAlchemy. e o biblioteca Python pentru
baze de date relationale(gen SQLite, MySQL, etc). iti ofera o abstractizare prin care
tu lucrezi direct cu clase Python si obiecte, fara sa scrii deloc SQL, ceea ce face sa
fie mai usor. e independent de motorul de baza de date, deci poti sa treci de exemplu
de la SQLite la MySQL fara sa rescrii tot codul. asta il poate face sa fie putin mai lent,
dar daca nu sunt query-uri insane cred ca e ok. puteam sa folosesc direct SQLite, deci daca 
vreti schimbam. in cod e o linie "db.init_app(app)" prin care se leaga obiectul db (o
instanta SQLAlchemy) de app (aplicatia noastra).
- cu comanda "flask shell" pornesti un interpretor Python interactiv cu aplicatia ta. 
comanda asta face automat directorul "__pycache__". codul sursa este compilat in bytecode
(.pyc), care e o versiune intermediara mai rapida decat codul text (.py), care se salveaza
in acest director ca sa nu fie recompilat la fiecare rulare.
- din flask shell scriem "db.create_all()". ce face comanda asta e ca se uita la toate modelele
pe care le-am definit cu SQLAlchemy, verifica daca am conectat baza la o aplicatie gen SQLite sau
MySQL, apoi creeaza tabelele pe baza definitiilor. si asa apare acel dev.db unde e definita schema.
- problema e ca daca modificam ulterior schema, nu o putem actualiza cu "db.create_all()". asa ca e 
nevoie sa o *migram*. iar aici intervine acel director migrations. pentru asta se foloseste un tool
ca Flask-Migrate/Alembic. in cod este o linie "migrate = Migrate(app, db)". aici se creeaza un 
obiect care leaga aplicatia (app) de baza de date (db). practic ii spune lui Alembic "uite modelele
mele SQLAlchemy, vezi care sunt si fa scripturi de migrare pentru cand se schimba". nu face migrarea
direct, dar se face prin comenzi. asa ca dam comanda "flask db init" ca sa initializam sistemul de 
migrare. e de fapt un mini repo, ca git, doar ca pentru baze de date. cand dam comanda "flask db 
migrate -m "descriere schimbare" " ni se compara modelele SQLAlchemy cu schema actuala si se creeaza
un script Python in migrations/versions/. apoi dam "flask db upgrade", prin care sunt citite 
scripturile si aplicate schimbarile in baza de date. 